package astar;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AStar {

    public String mMetadataFilePath;
    private Spot[][] mGrid;
    final static int GRID_SIZE = 25;

    /**
     *
     * links adjacent squares of mGrid
     */
    public void linkHorizontalNeighbors() {
        for (int i = 0; i < mGrid.length; i++) {
            for (int j = 0; j < (mGrid[i].length) - 1; j++) {
                if (i > 0) {
                    mGrid[i][j].addNeighbor(mGrid[i - 1][j]);
                }
                if (j > 0) {
                    mGrid[i][j].addNeighbor(mGrid[i][j - 1]);
                }
                if (i < mGrid.length - 1) {
                    mGrid[i][j].addNeighbor(mGrid[i + 1][j]);
                }
                if (j < mGrid.length - 1) {
                    mGrid[i][j].addNeighbor(mGrid[i][j + 1]);
                }
                if (i > 0 && j > 0) {
                    mGrid[i][j].addNeighbor(mGrid[i - 1][j - 1]);
                }
                if (i < mGrid.length - 1 && j < mGrid.length - 1) {
                    mGrid[i][j].addNeighbor(mGrid[i + 1][j + 1]);
                }
            }
        }
    }

    /**
     *
     * @param coords
     * @return A square with coords, of max and min values
     */
    public Edges pointsToArea(JSONObject coords) {
        // The min max default values are set
        // respectively to the 25x25 array size
        // generated by the metadata tool
        int minX = GRID_SIZE;
        int minY = GRID_SIZE;
        int maxX = 0;
        int maxY = 0;

        for (int i = 0; i < coords.size(); i++) {

            JSONObject xy = (JSONObject) coords.get(String.valueOf(i));

            int x = Math.toIntExact((long) xy.get("x"));
            int y = Math.toIntExact((long) xy.get("y"));

            if (x < minX) {
                minX = x;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (y > maxY) {
                maxY = y;
            }
        }

        return new Edges(minX, maxX, minY, maxY);
    }

    /**
     *
     * @param start
     * @param end
     * @param in
     * @return start and end point squares
     */
    public Edges[] getDictFromJSON(Destination start, Destination end, InputStreamReader in) {

        JSONParser parser = new JSONParser();

        //filePath is assumed to have a path to JSON
        //think about exception handling

        JSONObject json = null;
        try {
            json = (JSONObject) parser.parse(in);

        } catch (ParseException | IOException e) {
            e.printStackTrace();
        }

        JSONObject startCoords = getDict(start, json);
        JSONObject endCoords = getDict(end, json);

        Edges startDict = pointsToArea(startCoords);
        Edges endDict = pointsToArea(endCoords);

        Edges[] startEnd = {startDict, endDict};

        return startEnd;
    }

    /**
     *
     * @param destination
     * @param json
     * @return
     */
    public JSONObject getDict(Destination destination, JSONObject json) {
        json = (JSONObject) json.get(destination.mBuilding);
        json = (JSONObject) json.get(destination.mFloor);
        json = (JSONObject) json.get(destination.mRoom);

        return json;
    }

    /**
     *
     * @param dest
     * @return parsed string to destination object
     */
    public Destination setDestFromString(String dest) {
        // Assuming string has the following format %s-%d%d%d
        // or %s-%s%d.%d%d%d. The regex operation is able to
        // extract the information needed to instantiate the
        // Destination object.

        String roomRegex = "(\\S{1,2})\\s((\\w?\\d\\.|\\w)?(\\d{3,4}))";

        Pattern roomPattern = Pattern.compile(roomRegex);
        Matcher m = roomPattern.matcher(dest);

        Destination destination = new Destination();

        if (m.matches()) {
            destination.setmBuilding(m.group(1));
            destination.setmRoom(m.group(0));
            destination.setmFloor(m.group(2).substring(0, 1));
        } else {
            // handle exception
        }

        return destination;
    }

    /**
     *
     * @param bool
     */
    public void initializeSpotGrid(boolean[][] bool) {
        mGrid = new Spot[bool.length][bool[bool.length - 1].length];

        for (int i = 0; i < mGrid.length; i++) {
            for (int j = 0; j < mGrid[i].length; j++) {
                mGrid[i][j] = new Spot(i, j, bool[i][j]);
            }
        }
    }

    /**
     *
     * @param bool
     * @param startEnd
     */
    public void createSpotGrid(boolean[][] bool, Edges[] startEnd) {

        mGrid = new Spot[bool.length][bool[bool.length - 1].length];

        for (int i = 0; i < mGrid.length; i++) {
            for (int j = 0; j < mGrid[i].length; j++) {
                if (i <= startEnd[0].getRight()
                        && i >= startEnd[0].getLeft()
                        && j <= startEnd[0].getTop()
                        && j >= startEnd[0].getBottom()) {

                    mGrid[i][j] = new Spot(i, j, false);

                } else if (i <= startEnd[1].getRight()
                        && i >= startEnd[1].getLeft()
                        && j <= startEnd[1].getTop()
                        && j >= startEnd[1].getBottom()) {

                    mGrid[i][j] = new Spot(i, j, false);

                } else {

                    mGrid[i][j] = new Spot(i, j, bool[i][j]);

                }
            }
        }
    }

    /**
     *
     * @param startCoords
     * @param endCoords
     * @return linked list of nodes (Spot), iterate through the nodes by using Spot.getPrevious()
     */
    public Spot runAlgorithm(int[] startCoords, int[] endCoords) {

        List<Spot> openSet = new ArrayList<>();
        List<Spot> closedSet = new ArrayList<>();

        Spot start = mGrid[startCoords[1]][startCoords[0]];
        Spot end = mGrid[endCoords[1]][endCoords[0]];

        if (start.isWall() || end.isWall()) {
            return null;
        }

        start.setH(getDistance(start, end));
        start.updateF();

        openSet.add(start);

        Spot current;
        Spot path = null;

        while (openSet.size() > 0) {

            //check the node in the openSet with lowest F score
            current = openSet.get(0);

            for (Spot candidate : openSet) {
                if (candidate.getF() == current.getF()) {
                    if (candidate.getG() < current.getG()) {
                        current = candidate;
                    }
                }
                if (candidate.getF() < current.getF()) {
                    current = candidate;
                }
            }

            openSet.remove(current);
            closedSet.add(current);

            for (Spot neighbor : current.getNeighbors()) {
                if (!closedSet.contains(neighbor) && !neighbor.isWall()) {

                    double tent_score = current.getG() + getDistance(current, neighbor);

                    if (openSet.contains(neighbor)) {
                        if (tent_score < neighbor.getG()) {

                            neighbor.setG(tent_score);

                        }
                    } else {

                        neighbor.setG(tent_score);
                        openSet.add(neighbor);

                    }

                    neighbor.setPrevious(current);

                    neighbor.setH(getDistance(neighbor, end));
                    neighbor.updateF();

                }

            }

            if (current.equals(end)) {
                path = current;
                break;
            }

        }


        return path;

    }

    /**
     *
     * @param a
     * @param b
     * @return Chebyshev distance formula
     */
    private double getDistance(Spot a, Spot b) {
        int deltaX = a.getX() - b.getX();
        int deltaY = a.getY() - b.getY();
        return ((Math.max(Math.abs(deltaX), Math.abs(deltaY))));
    }

}
